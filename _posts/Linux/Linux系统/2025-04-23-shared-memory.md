---
title: Linux进程间通信之共享内存
description: 共享内存是实现同机进程间通信（IPC）的一种高效方式，它允许多个进程直接访问同一块物理内存区域，避免了数据复制的开销。
author: yu
date: 2025-04-23 15:37:00 +0800
categories: [Linux, Linux系统编程]
tags: [Linux]
---

## 前言

`共享内存`（Shared Memory）是实现**同机**`进程间通信`（Inter-Process Communication，简称`IPC`）的一种高效方式，它**允许多个进程直接访问同一块物理内存区域**，避免了数据复制的开销。

## 共享内存的核心原理

1. **内存映射**
操作系统在内核中分配一块物理内存，多个进程将其映射到各自的虚拟地址空间，这块内存就是`共享内存`。

2. **直接访问**
进程通过指针直接读写共享内存，无需系统调用（如 `read`/`write`），速度接近普通内存操作，是`最快的IPC方式`。

3. **无结构数据**
共享内存本身只是一块字节流，进程需自行定义数据格式（如结构体、协议头等）。

## 共享内存相关命令

ipcs: 查看共享内存
```bash
ipcs -m
```

ipcrm: 删除共享内存
```bash
ipcrm -m shmid
ipcrm -M shmkey
```

## Linux共享内存相关函数

### shmget函数

```cpp
#include <sys/ipc.h>
#include <sys/shm.h>
int shmget(key_t key, size_t size, int shmflg);  // 返回共享内存标识符
```
- key: 共享内存标识符或键值，用于标识共享内存，推荐使用`十六进制`（如 0x5005），因为`ipcs -m`命令 显示的key为十六进制，二者一致方便查看。
- size: 共享内存的大小，以字节为单位。
- shmflg: 标志位，用于控制共享内存的创建和访问权限。

return: 成功返回共享内存标识符，失败返回-1。如果key不存在，则创建共享内存，如果key已存在，则获得共享内存。

### shmat函数

### shmdt函数

### shmctl函数

### close函数


## 实现步骤（以 POSIX API 为例）



## 同步机制（关键！）

**共享内存本身不提供同步**，即在某一个进程对共享内存进行读/写的时候，不会阻止其它进程对它的读/写。

如果有需要，需结合其他 IPC 机制防止竞态条件。由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。
如果要对共享内存的读/写加锁，可以使用`信号量`。

## 注意

1. 不要使用`C++`的`std::string`等有可能分配`堆内存`的容器，作为向共享内存写入的数据类型。
例如`std::string`保存长字符串时，这个长字符串会存储在堆空间，而std::string对象位于栈内存，会保存一个指向堆内存的指针，同时记录字符串的长度和容量等数据。将此std::string对象写入共享内存时，实际写入的是它的成员变量（包括指针、长度、容量等），而 **堆内存中的字符串数据本身并不会被复制到共享内存**。

向共享内存写入字符串，通常需要使用字符数组 或 自定义数据格式，如：
```cpp
const int MaxSize = 4096;

char shared_buffer[MaxSize];  // 直接使用字符数组

// 自定义：共享内存结构定义
struct SharedData
{
    char message[MaxSize]; // 固定大小数组
    int message_length;   // 显式存储字符串长度（可选）
    // ... 其他数据
};
```
